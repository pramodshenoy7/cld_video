{"version":3,"sources":["../../../../../src/streaming/controllers/EventController.js"],"names":["EventController","MPD_RELOAD_SCHEME","MPD_RELOAD_VALUE","MPD_CALLBACK_SCHEME","MPD_CALLBACK_VALUE","REFRESH_DELAY","REMAINING_EVENTS_THRESHOLD","context","eventBus","getInstance","instance","logger","inlineEvents","inbandEvents","activeEvents","eventInterval","lastEventTimerCall","manifestUpdater","playbackController","eventHandlingInProgress","isStarted","setup","getLogger","_resetInitialSettings","checkConfig","Error","Date","now","_stop","clearInterval","_onStopEventController","e","start","debug","isNaN","setInterval","_onEventTimer","addInlineEvents","values","i","length","event","id","_startEvent","MediaPlayerEvents","EVENT_MODE_ON_RECEIVE","addInbandEvents","eventStream","schemeIdUri","undefined","_handleManifestReloadEvent","value","validUntil","calculatedPresentationTime","newDuration","NaN","duration","trigger","MANIFEST_VALIDITY_CHANGED","newManifestValidAfter","mode","EVENT_MODE_ON_START","_removeEvents","currentVideoTime","getTime","eventIds","Object","keys","eventId","presentationTimeThreshold","Math","max","_triggerEvents","_triggerRemainingEvents","events","_eventHasExpired","_eventIsInvalid","threshold","calculatedPresentationTimeInSeconds","periodEndTime","period","currentTime","periodDuration","periodStart","forEach","abs","presentationTimeDelta","_refreshManifest","_sendCallbackRequest","messageData","refreshManifest","url","loader","create","load","method","request","responseType","setConfig","config","reset","__dashjs_factory_name","FactoryMaker","getSingletonFactory"],"mappings":"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","file":"EventController.js","sourcesContent":["/**\n * The copyright in this software is being made available under the BSD License,\n * included below. This software may be subject to other third party and contributor\n * rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Dash Industry Forum.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *  * Redistributions of source code must retain the above copyright notice, this\n *  list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *  this list of conditions and the following disclaimer in the documentation and/or\n *  other materials provided with the distribution.\n *  * Neither the name of Dash Industry Forum nor the names of its\n *  contributors may be used to endorse or promote products derived from this software\n *  without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\n\nimport FactoryMaker from '../../core/FactoryMaker';\nimport Debug from '../../core/Debug';\nimport EventBus from '../../core/EventBus';\nimport MediaPlayerEvents from '../../streaming/MediaPlayerEvents';\nimport XHRLoader from '../net/XHRLoader';\n\nfunction EventController() {\n\n    const MPD_RELOAD_SCHEME = 'urn:mpeg:dash:event:2012';\n    const MPD_RELOAD_VALUE = 1;\n\n    const MPD_CALLBACK_SCHEME = 'urn:mpeg:dash:event:callback:2015';\n    const MPD_CALLBACK_VALUE = 1;\n\n    const REFRESH_DELAY = 100;\n    const REMAINING_EVENTS_THRESHOLD = 300;\n\n    const context = this.context;\n    const eventBus = EventBus(context).getInstance();\n\n    let instance,\n        logger,\n        inlineEvents, // Holds all Inline Events not triggered yet\n        inbandEvents, // Holds all Inband Events not triggered yet\n        activeEvents, // Holds all Events currently running\n        eventInterval, // variable holding the setInterval\n        lastEventTimerCall,\n        manifestUpdater,\n        playbackController,\n        eventHandlingInProgress,\n        isStarted;\n\n    function setup() {\n        logger = Debug(context).getInstance().getLogger(instance);\n        _resetInitialSettings();\n    }\n\n    function checkConfig() {\n        if (!manifestUpdater || !playbackController) {\n            throw new Error('setConfig function has to be called previously');\n        }\n    }\n\n    function _resetInitialSettings() {\n        isStarted = false;\n        inlineEvents = {};\n        inbandEvents = {};\n        activeEvents = {};\n        eventInterval = null;\n        eventHandlingInProgress = false;\n        lastEventTimerCall = Date.now() / 1000;\n    }\n\n    function _stop() {\n        try {\n            if (eventInterval !== null && isStarted) {\n                clearInterval(eventInterval);\n                eventInterval = null;\n                isStarted = false;\n                _onStopEventController();\n            }\n        } catch (e) {\n            throw e;\n        }\n    }\n\n    function start() {\n        try {\n            checkConfig();\n            logger.debug('Start Event Controller');\n            if (!isStarted && !isNaN(REFRESH_DELAY)) {\n                isStarted = true;\n                eventInterval = setInterval(_onEventTimer, REFRESH_DELAY);\n            }\n        } catch (e) {\n            throw e;\n        }\n    }\n\n    /**\n     * Add events to the eventList. Events that are not in the mpd anymore but not triggered yet will still be deleted\n     * @param {Array.<Object>} values\n     */\n    function addInlineEvents(values) {\n        try {\n            checkConfig();\n\n            if (values) {\n                for (let i = 0; i < values.length; i++) {\n                    let event = values[i];\n                    logger.debug('Add inline event with id ' + event.id);\n\n                    // If we see the event for the first time we trigger it in onReceive mode\n                    if (!inlineEvents[event.id]) {\n                        _startEvent(event.id, event, values, MediaPlayerEvents.EVENT_MODE_ON_RECEIVE);\n                    }\n\n                    inlineEvents[event.id] = event;\n                }\n            }\n            logger.debug(`Added ${values.length} inline events`);\n        } catch (e) {\n            throw e;\n        }\n    }\n\n    /**\n     * i.e. processing of any one event message box with the same id is sufficient\n     * @param {Array.<Object>} values\n     */\n    function addInbandEvents(values) {\n        try {\n            checkConfig();\n\n            for (let i = 0; i < values.length; i++) {\n                let event = values[i];\n                if (!(event.id in inbandEvents)) {\n                    if (event.eventStream.schemeIdUri === MPD_RELOAD_SCHEME && inbandEvents[event.id] === undefined) {\n                        _handleManifestReloadEvent(event);\n                    }\n                    inbandEvents[event.id] = event;\n                    logger.debug('Add inband event with id ' + event.id);\n                    _startEvent(event.id, event, values, MediaPlayerEvents.EVENT_MODE_ON_RECEIVE);\n                } else {\n                    logger.debug('Repeated event with id ' + event.id);\n                }\n            }\n            _onEventTimer();\n        } catch (e) {\n            throw e;\n        }\n    }\n\n    function _handleManifestReloadEvent(event) {\n        try {\n            if (event.eventStream.value == MPD_RELOAD_VALUE) {\n                const validUntil = event.calculatedPresentationTime;\n                let newDuration;\n                if (event.calculatedPresentationTime == 0xFFFFFFFF) {//0xFF... means remaining duration unknown\n                    newDuration = NaN;\n                } else {\n                    newDuration = event.calculatedPresentationTime + event.duration;\n                }\n                //logger.info('Manifest validity changed: Valid until: ' + validUntil + '; remaining duration: ' + newDuration);\n                eventBus.trigger(MediaPlayerEvents.MANIFEST_VALIDITY_CHANGED, {\n                    id: event.id,\n                    validUntil: validUntil,\n                    newDuration: newDuration,\n                    newManifestValidAfter: NaN //event.message_data - this is an arraybuffer with a timestring in it, but not used yet\n                }, {\n                    mode: MediaPlayerEvents.EVENT_MODE_ON_START\n                });\n            }\n        } catch (e) {\n        }\n    }\n\n    /**\n     * Remove expired events from the list\n     */\n    function _removeEvents() {\n        try {\n            if (activeEvents) {\n                let currentVideoTime = playbackController.getTime();\n                let eventIds = Object.keys(activeEvents);\n\n                for (let i = 0; i < eventIds.length; i++) {\n                    let eventId = eventIds[i];\n                    let event = activeEvents[eventId];\n                    if (event !== null && event.duration + event.calculatedPresentationTime < currentVideoTime) {\n                        logger.debug('Remove Event ' + eventId + ' at time ' + currentVideoTime);\n                        event = null;\n                        delete activeEvents[eventId];\n                    }\n                }\n            }\n        } catch (e) {\n        }\n    }\n\n    /**\n     * Iterate through the eventList and trigger/remove the events\n     */\n    function _onEventTimer() {\n        try {\n            if (!eventHandlingInProgress) {\n                eventHandlingInProgress = true;\n                const currentVideoTime = playbackController.getTime();\n                let presentationTimeThreshold = (currentVideoTime - lastEventTimerCall);\n\n                // For dynamic streams lastEventTimeCall will be large in the first iteration. Avoid firing all events at once.\n                presentationTimeThreshold = lastEventTimerCall > 0 ? Math.max(0, presentationTimeThreshold) : 0;\n\n                _triggerEvents(inbandEvents, presentationTimeThreshold, currentVideoTime);\n                _triggerEvents(inlineEvents, presentationTimeThreshold, currentVideoTime);\n                _removeEvents();\n\n                lastEventTimerCall = currentVideoTime;\n                eventHandlingInProgress = false;\n            }\n        } catch (e) {\n            eventHandlingInProgress = false;\n        }\n    }\n\n    function _onStopEventController() {\n        try {\n            // EventController might be stopped before the period is over. Before we stop the event controller we check for events that needs to be triggered at the period boundary.\n            _triggerRemainingEvents(inbandEvents);\n            _triggerRemainingEvents(inlineEvents);\n        } catch (e) {\n\n        }\n    }\n\n    function _triggerEvents(events, presentationTimeThreshold, currentVideoTime) {\n        try {\n            if (events) {\n                let eventIds = Object.keys(events);\n\n                for (let i = 0; i < eventIds.length; i++) {\n                    let eventId = eventIds[i];\n                    let event = events[eventId];\n\n                    if (event !== undefined) {\n                        const duration = !isNaN(event.duration) ? event.duration : 0;\n                        // The event is either about to start or has already been started and we are within its duration\n                        if ((event.calculatedPresentationTime <= currentVideoTime && event.calculatedPresentationTime + presentationTimeThreshold + duration >= currentVideoTime)) {\n                            _startEvent(eventId, event, events, MediaPlayerEvents.EVENT_MODE_ON_START);\n                        } else if (_eventHasExpired(currentVideoTime, duration + presentationTimeThreshold, event.calculatedPresentationTime) || _eventIsInvalid(event)) {\n                            logger.debug(`Deleting event ${eventId} as it is expired or invalid`);\n                            delete events[eventId];\n                        }\n                    }\n                }\n            }\n        } catch (e) {\n        }\n    }\n\n    function _eventHasExpired(currentVideoTime, threshold, calculatedPresentationTimeInSeconds) {\n        try {\n            return currentVideoTime - threshold > calculatedPresentationTimeInSeconds;\n        } catch (e) {\n            return false;\n        }\n    }\n\n    function _eventIsInvalid(event) {\n        try {\n            const periodEndTime = event.eventStream.period.start + event.eventStream.period.duration;\n\n            return event.calculatedPresentationTime  > periodEndTime;\n        } catch (e) {\n            return false;\n        }\n    }\n\n    function _triggerRemainingEvents(events) {\n        try {\n            const eventIds = Object.keys(events);\n            const currentTime = playbackController.getTime();\n\n            if (!eventIds || eventIds.length === 0) {\n                return;\n            }\n\n            const periodDuration = events[eventIds[0]].eventStream && events[eventIds[0]].eventStream.period && !isNaN(events[eventIds[0]].eventStream.period.duration) ? events[eventIds[0]].eventStream.period.duration : NaN;\n            const periodStart = events[eventIds[0]].eventStream && events[eventIds[0]].eventStream.period && !isNaN(events[eventIds[0]].eventStream.period.start) ? events[eventIds[0]].eventStream.period.start : NaN;\n\n            if (isNaN(periodDuration) || isNaN(periodStart)) {\n                return;\n            }\n\n            eventIds.forEach((eventId) => {\n                const event = events[eventId];\n                const calculatedPresentationTimeInSeconds = event.calculatedPresentationTime;\n\n                if (Math.abs(calculatedPresentationTimeInSeconds - currentTime) < REMAINING_EVENTS_THRESHOLD) {\n                    _startEvent(eventId, event, events, MediaPlayerEvents.EVENT_MODE_ON_START);\n                }\n            });\n        } catch (e) {\n\n        }\n    }\n\n    function _startEvent(eventId, event, events, mode) {\n        try {\n            const currentVideoTime = playbackController.getTime();\n\n            if (mode === MediaPlayerEvents.EVENT_MODE_ON_RECEIVE) {\n                logger.debug(`Received event ${eventId}`);\n                eventBus.trigger(event.eventStream.schemeIdUri, { event: event }, { mode });\n                return;\n            }\n\n            if (event.duration > 0) {\n                activeEvents[eventId] = event;\n            }\n\n            if (event.eventStream.schemeIdUri === MPD_RELOAD_SCHEME && event.eventStream.value === MPD_RELOAD_VALUE) {\n                if (event.duration !== 0 || event.presentationTimeDelta !== 0) { //If both are set to zero, it indicates the media is over at this point. Don't reload the manifest.\n                    logger.debug(`Starting manifest refresh event ${eventId} at ${currentVideoTime}`);\n                    _refreshManifest();\n                }\n            } else if (event.eventStream.schemeIdUri === MPD_CALLBACK_SCHEME && event.eventStream.value === MPD_CALLBACK_VALUE) {\n                logger.debug(`Starting callback event ${eventId} at ${currentVideoTime}`);\n                _sendCallbackRequest(event.messageData);\n            } else {\n                logger.debug(`Starting event ${eventId} at ${currentVideoTime}`);\n                eventBus.trigger(event.eventStream.schemeIdUri, { event: event }, { mode });\n            }\n\n            delete events[eventId];\n\n        } catch (e) {\n        }\n    }\n\n    function _refreshManifest() {\n        try {\n            checkConfig();\n            manifestUpdater.refreshManifest();\n        } catch (e) {\n        }\n    }\n\n    function _sendCallbackRequest(url) {\n        try {\n            let loader = XHRLoader(context).create({});\n            loader.load({\n                method: 'get',\n                url: url,\n                request: {\n                    responseType: 'arraybuffer'\n                }\n            });\n        } catch (e) {\n            throw e;\n        }\n    }\n\n    function setConfig(config) {\n        try {\n            if (!config) {\n                return;\n            }\n\n            if (config.manifestUpdater) {\n                manifestUpdater = config.manifestUpdater;\n            }\n\n            if (config.playbackController) {\n                playbackController = config.playbackController;\n            }\n        } catch (e) {\n            throw e;\n        }\n    }\n\n    function reset() {\n        _stop();\n        _resetInitialSettings();\n    }\n\n    instance = {\n        addInlineEvents,\n        addInbandEvents,\n        start,\n        setConfig,\n        reset\n    };\n\n    setup();\n\n    return instance;\n}\n\nEventController.__dashjs_factory_name = 'EventController';\nexport default FactoryMaker.getSingletonFactory(EventController);\n"]}